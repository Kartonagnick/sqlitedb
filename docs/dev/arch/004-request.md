
request
-------
Служебный класс.  
Предназначен для установки аргументов запроса, и получения результатов.  

- [ ] [Требования][0]  
- [x] Члены класса:  
  - [ ] [Деструктор][1]  
  - [ ] [Конструкторы][2]  
  - [ ] Операторы присвоения запрещены.  
  - [ ] [operator<<(T&&)][3]  
  - [ ] [operator>>(T&&)][4]  

[0]: #Требования      "требования к реализации"  
[1]: #Деструктор      "описание деструктора"  
[2]: #Конструкторы    "описание конструкторов"  
[3]: #operator-in     "оператор ввода аргумента"  
[3]: #operator-out    "оператор вывода аргумента"  

<br />
<br />




Требования
----------
 - [x] Может быть создан только [connection](003-connection.md)  
 - [x] В нормальной ситуации остается временным объектом до конца жизни.  
 - [x] Не перемещаем.  
   - [x] Перемещающий конструктор существует, 
         но пользоваться им может только [connection](003-connection.md)  
 - [x] Не копируемый.  
 - [x] Операторы присвоения запрещены.  

<br />
<br />





Деструктор
----------

```cpp
~request();
```

- [ ] Защищён при помощи assert.  
- [ ] Гарантирует noexcept (no-throw guarantee).  
- [ ] Закрывает запрос, подтвердив все изменения .  

<br />
<br />





Конструкторы
------------

```cpp
private:
    request(request&&)     noexcept;
    request(stmtT* cursor) noexcept;
public:
    request(const request&)            = delete;
    request& operator=(const request&) = delete;
    request& operator=(request&&)      = delete;
```

- [x] Создать объект может только [connection](003-connection.md)  
- [x] Перемещать объект может только [connection](003-connection.md)  
- [x] Конструктор копии запрещен.
- [x] Операторы присвоения запрещены.

<br />
<br />


operator-in 
-----------
Служит для ввода аргументов запроса.  
```
    template<class T>
    request& operator << (T&& value) noexcept;
```

- [x] Возвращает ссылку на самого себя.  
- [x] Никогда не бросает исключений.  
- [x] Защищается assert  
- [ ] Поддерживаемые типы:  
  - [ ] const char*  
  - [ ] const str_t  
  - [ ] float или double.  
  - [ ] int любых размерностей.  
  - [ ] bool.  
- [x] Типы аргументов могут не совпадать с типами столбцов.  
  - [x] За исключением столбца PRIMARY KEY.  
    - [x] PRIMARY KEY обязан быть int (любой размерности).  

<br />
<br />






operator-out
------------
Служит для получения итоговых результатов запроса.  
```
    template<class T>
    void operator >> (T& dst);
```

- [x] Может бросить исключение. (например: std::bad_alloc)  
- [x] Защищается assert  
- [ ] Поддерживаемые типы:  
  - [ ] const char*  
  - [ ] const str_t  
  - [ ] float или double.  
  - [ ] int любых размерностей.  
  - [ ] bool.  
- [x] Типы аргументов могут не совпадать с типами столбцов.  
  - [x] За исключением столбца PRIMARY KEY.  
    - [x] PRIMARY KEY обязан быть int (любой размерности).  
- [x] Количество строк ответа может быть больше, 
      чем ожидает получатель, но не меньше.  
- [x] Количество столбцов в строке ответа может быть больше, 
      чем ожидает получатель, но не меньше.  

# Получателем данных может быть одиночная переменная
Используется в случаях, когда от базы в ответ 
ожидается одно единственное значение.  
И это единственное значение всегда должно быть.  
Например:  
  `Сonnection << "select count(*) from sample" >> count;`  

Здесь `count(*)` может быть либо ноль, либо больше.  
Но какое то значение всегда должно быть.  
Пустой ответ от базы расценивается как ошибка.  

- [x] Если база пришлет в ответ пустую строку:  
  - [x] В дебаге ->assert  
  - [x] В релизе -> исключение.  
- [x] Если база пришлет в ответ строку из нескольких столбцов:  
  - [x] Будет использованно значение только первого столбца.  
  - [x] Остальные столбцы будут проигонорированы.  
- [x] Если база пришлет несколько строк ответа:  
  - [x] В дебаге сработает assert  
  - [x] В релизе:  
    - [x] Будет использовано значение первого столбца первой строки.  
    - [x] Все остальное будет проигноированно.  

# Получателем данных может быть std::tuple
Используется в случаях, когда от базы в ответ 
ожидается одна единственная строка из нескольких столбцов.  
По понятным причинам, ответ базы может быть: "по вашему запросу ничего не найдено".  

Пример использования:
```
    std::tuple<str_t, int> dst
    Сonnection << "SELECT * FROM users WHERE login = 1" >> dst;
```

- [x] Параметры std::tuple соответствуют типам столбцов в строке ответа.  
- [x] Параметры std::tuple не обязаны строго совпадать с типами столбцов в строке ответа.  
  - [x] Есди не совпадают -> sqlite3 выполнит приведение типов.  
- [x] Если количество параметров std::tuple больше, чем количество столбцов в строке ответа, тогда:  
  - [x] В релизе -> исключение.  
  - [x] В дебаге -> assert.  
- [x] Если количество параметров std::tuple меньше, чем количество столбцов в строке ответа, тогда:  
  - [x] Избыточные столбцы в строке ответа будут проигнорированы.  
- [x] Если количество строк в ответе будет больше одной:  
  - [x] В релизе первая строка будет обработана, а остальные проигнорированы.  
  - [x] В дебаге сработает assert.  
- [x] Если количество строк в ответе равно нулю (пустой ответ):  
  - [x] std::tuple остаётся без изменений.  
- [x] `std::tuple<>` - кортёж без параметров запрещен.  

<br />
<br />





# Получателем данных может быть std::tie
Практически тоже самое, что и std::tuple.
Только переменные-получатели могут быть обособленные.

Пример использования:
```
    str_t name;
    size_t age;
    Сonnection << "SELECT * FROM users WHERE name = 'Denis'" >> std::tie(name, age);
```

- [x] Аргументы std::tie соответствуют типам столбцов в строке ответа.  
- [x] Аргументы std::tie не обязаны строго совпадать с типами столбцов в строке ответа.  
  - [x] Есди не совпадают -> sqlite3 выполнит приведение типов.  
- [x] Если количество аргументов std::tie больше, чем количество столбцов в строке ответа, тогда:  
  - [x] В релизе -> исключение.  
  - [x] В дебаге -> assert.  
- [x] Если количество аргументов std::tie меньше, чем количество столбцов в строке ответа, тогда:  
  - [x] Избыточные столбцы в строке ответа будут проигнорированы.  
- [x] Если количество строк в ответе будет больше одной:  
  - [x] В релизе первая строка будет обработана, а остальные проигнорированы.  
  - [x] В дебаге сработает assert.  
- [x] Если количество строк в ответе равно нулю (пустой ответ):  
  - [x] Переменные-получатели остануться без изменений.  
- [x] `std::tie()` - без параметров запрещен.  

<br />
<br />




# Получателем данных может быть лямбда  
Используется для перебора множества строк ответа базы.  
Пример: `auto getter = [](str_t&, int&) { return true; };`  

- [x] Лямбда вызывается в цикле для обработки очередной строки.  
  - [x] Если лямбда возвращает false -> это сигнал прекратить цикл.  
  - [x] Если лямбда возвращает true -> это запрос следующей строки.  
- [x] Аргументы лямбды соответствуют типам столбцов в строке ответа.  
- [x] Типы аргументов могут не совпдать с типами столбцов:  
  - [x] В этом случае sqlite3 выполнит приведение типов.  
- [x] Количество аргументов лямбды может быть меньше, чем количество столбцов в строке ответа.  
  - [x] В этом случае избыточные столбцы будут проигнорированы.  
- [x] Количество аргументов лямбды не должно быть больше, чем количество столбцов в строке ответа.  
  - [x] В релизе будет брошено исключение.  
  - [x] В дебаге сработает assert.  
- [x] База может прислать пустой ответ:  
  - [x] В этом случае лямбда запускаться не будет.  

<br />
<br />

# Допустимые типы получателя:  
  - [x] str_t  
  - [x] float или double.  
  - [x] int любых размерностей.  
  - [x] bool.  
  - Либо лямбда с аргументами указанных выше типов:  
    - [x] Например такая:  
      - `auto getter = [](str_t&, int&) { return true; };`  
    - [x] Лямбда должна возвращать bool  
  - Либо std::tuple, параметризованный указанными выше типами:  
    - [x] Например такой: `std::tuple<str_t, int>`  
  - Либо std::tie, параметризованный указанными выше типами:  
    - [x] Например такой:  
      - `std::tie(text, age); //text b age - переменные типа str_t, и int соответственно`  
  - Либо std::list или std::vector, параметризованные указанными выше типами:  
    - [x] Например такие:  
      - `std::vector<int>`  
      - `std::list<str_t>`  
      - `std::list<std::tuple<str_t, int> >`  

