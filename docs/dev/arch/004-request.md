
request
-------
Служебный класс.  
Предназначен для установки аргументов запроса, и получения результатов.  

- [ ] [Требования][0]  
- [x] Члены класса:  
  - [ ] [Деструктор][1]  
  - [ ] [Конструкторы][2]  
  - [ ] Операторы присвоения запрещены.  
  - [ ] [operator<<(T&&)][3]  
  - [ ] [operator>>(T&&)][4]  

[0]: #Требования      "требования к реализации"  
[1]: #Деструктор      "описание деструктора"  
[2]: #Конструкторы    "описание конструкторов"  
[3]: #operator-in     "оператор ввода аргумента"  
[4]: #operator-out    "оператор вывода аргумента"  

<br />
<br />




Требования
----------
 - [x] Может быть создан только [connection](003-connection.md)  
 - [x] В нормальной ситуации остается временным объектом до конца жизни.  
 - [x] Не перемещаем.  
   - [x] Перемещающий конструктор существует, 
         но пользоваться им может только [connection](003-connection.md)  
 - [x] Не копируемый.  
 - [x] Операторы присвоения запрещены.  

<br />
<br />





Деструктор
----------

```cpp
~request();
```

- [ ] Защищён при помощи assert.  
- [ ] Гарантирует noexcept (no-throw guarantee).  
- [ ] Закрывает запрос, подтвердив все изменения .  

<br />
<br />





Конструкторы
------------

```cpp
private:
    request(request&&)     noexcept;
    request(stmtT* cursor) noexcept;
public:
    request(const request&)            = delete;
    request& operator=(const request&) = delete;
    request& operator=(request&&)      = delete;
```

- [x] Создать объект может только [connection](003-connection.md)  
- [x] Перемещать объект может только [connection](003-connection.md)  
- [x] Конструктор копии запрещен.
- [x] Операторы присвоения запрещены.

<br />
<br />


operator-in 
-----------
Служит для ввода аргументов запроса.  
```
    template<class T>
    request& operator << (T&& value) &&;
```

- [x] Может быть [специализирован][5]  
- [x] Требует, что бы `request` был временным объектом.  
- [x] Возвращает ссылку на самого себя.  
- [x] Если аргументов слишком много -> assert/exception.  
- [x] Если аргументов слишком мало -> assert/exception.  
- [x] Защищается assert  
- [ ] Поддерживаемые типы:  
  - [ ] const char*  
  - [ ] const str_t  
  - [ ] float или double.  
  - [ ] int любых размерностей.  
  - [ ] bool.  
- [x] Типы аргументов могут не совпадать с типами столбцов.  
  - [x] За исключением столбца PRIMARY KEY.  
    - [x] PRIMARY KEY обязан быть int (любой размерности).  

[5]: #специализация-operatort-arg    "специализация шаблона для пользовательских типов"  

<br />
<br />

# Специализация operator<<(T&& arg)
Пользователи могут специализировать `оператор<<` для работы со своими классами.  
Тогда объекты классов можно будет использовать в качестве аргументов запроса.  
Пример специализации:  

```
    struct user_request
    {
        size_t login;
        size_t age;
    };

    db::request&& operator <<(db::request&& out, const user_request& src)
    {
        return std::move(out) << src.login << src.age;
    }
```

Обратите внимание: `std::move(out)`, объект out должен быть `rvalue`  
Теперь структуру `user_request` можно использовать в качестве аргументов запроса:  

```
    const char* sql = "insert into users (login, age) values (?,?)";
    const user_request request { i, i * 2 };
    connection << sql << request;
```

- [x] Количество полей в структуре должно совпадать с количеством аргументов запроса.  
  - [x] В релизе -> exception  
  - [x] В дебаге -> assert  

<br />
<br />


operator-out
------------
Служит для получения итоговых результатов запроса.  
```
    template<class T>
    void operator >> (T& dst);
```
- [x] Может быть [специализирован][6]  
- [x] Может бросить исключение. (например: std::bad_alloc)  
- [x] Защищается assert  
- [ ] Поддерживаемые типы:  
  - [ ] const char*  
  - [ ] const str_t  
  - [ ] float или double.  
  - [ ] int любых размерностей.  
  - [ ] bool.  
- [x] Типы аргументов могут не совпадать с типами столбцов.  
  - [x] За исключением столбца PRIMARY KEY.  
    - [x] PRIMARY KEY обязан быть int (любой размерности).  
- [x] Количество строк ответа может быть больше, 
      чем ожидает получатель, но не меньше.  
- [x] Количество столбцов в строке ответа может быть больше, 
      чем ожидает получатель, но не меньше.  

[6]: #Получателем-данных-может-быть-объект-пользовательского-класса    "специализация шаблона для пользовательских типов"  

<br />
<br />




# Получателем данных может быть одиночная переменная
Используется в случаях, когда от базы в ответ 
ожидается одно единственное значение.  
И это единственное значение всегда должно быть.  
Например:  
  `Сonnection << "select count(*) from sample" >> count;`  

Здесь `count(*)` может быть либо ноль, либо больше.  
Но какое то значение всегда должно быть.  
Пустой ответ от базы расценивается как ошибка.  

- [x] Если база пришлет в ответ пустую строку:  
  - [x] В дебаге ->assert  
  - [x] В релизе -> исключение.  
- [x] Если база пришлет в ответ строку из нескольких столбцов:  
  - [x] Будет использованно значение только первого столбца.  
  - [x] Остальные столбцы будут проигонорированы.  
- [x] Если база пришлет несколько строк ответа:  
  - [x] В дебаге сработает assert  
  - [x] В релизе:  
    - [x] Будет использовано значение первого столбца первой строки.  
    - [x] Все остальное будет проигноированно.  

# Получателем данных может быть std::tuple
Используется в случаях, когда от базы в ответ 
ожидается одна единственная строка из нескольких столбцов.  
По понятным причинам, ответ базы может быть: "по вашему запросу ничего не найдено".  

Пример использования:
```
    std::tuple<str_t, int> dst
    Сonnection << "SELECT * FROM users WHERE login = 1" >> dst;
```

- [x] Параметры std::tuple соответствуют типам столбцов в строке ответа.  
- [x] Параметры std::tuple не обязаны строго совпадать с типами столбцов в строке ответа.  
  - [x] Есди не совпадают -> sqlite3 выполнит приведение типов.  
- [x] Если количество параметров std::tuple больше, чем количество столбцов в строке ответа, тогда:  
  - [x] В релизе -> исключение.  
  - [x] В дебаге -> assert.  
- [x] Если количество параметров std::tuple меньше, чем количество столбцов в строке ответа, тогда:  
  - [x] Избыточные столбцы в строке ответа будут проигнорированы.  
- [x] Если количество строк в ответе будет больше одной:  
  - [x] В релизе первая строка будет обработана, а остальные проигнорированы.  
  - [x] В дебаге сработает assert.  
- [x] Если количество строк в ответе равно нулю (пустой ответ):  
  - [x] std::tuple остаётся без изменений.  
- [x] `std::tuple<>` - кортёж без параметров запрещен.  

<br />
<br />





# Получателем данных может быть std::tie
Практически тоже самое, что и std::tuple.
Только переменные-получатели могут быть обособленные.

Пример использования:
```
    str_t name;
    size_t age;
    Сonnection << "SELECT * FROM users WHERE name = 'Denis'" >> std::tie(name, age);
```

- [x] Аргументы std::tie соответствуют типам столбцов в строке ответа.  
- [x] Аргументы std::tie не обязаны строго совпадать с типами столбцов в строке ответа.  
  - [x] Есди не совпадают -> sqlite3 выполнит приведение типов.  
- [x] Если количество аргументов std::tie больше, чем количество столбцов в строке ответа, тогда:  
  - [x] В релизе -> исключение.  
  - [x] В дебаге -> assert.  
- [x] Если количество аргументов std::tie меньше, чем количество столбцов в строке ответа, тогда:  
  - [x] Избыточные столбцы в строке ответа будут проигнорированы.  
- [x] Если количество строк в ответе будет больше одной:  
  - [x] В релизе первая строка будет обработана, а остальные проигнорированы.  
  - [x] В дебаге сработает assert.  
- [x] Если количество строк в ответе равно нулю (пустой ответ):  
  - [x] Переменные-получатели остануться без изменений.  
- [x] `std::tie()` - без параметров запрещен.  

<br />
<br />




# Получателем данных может быть лямбда  
Используется для перебора множества строк ответа базы.  
Пример: `auto getter = [](str_t&, int&) { return true; };`  

- [x] Лямбда вызывается в цикле для обработки очередной строки.  
  - [x] Если лямбда возвращает false -> это сигнал прекратить цикл.  
  - [x] Если лямбда возвращает true -> это запрос следующей строки.  
- [x] Аргументы лямбды соответствуют типам столбцов в строке ответа.  
- [x] Типы аргументов могут не совпдать с типами столбцов:  
  - [x] В этом случае sqlite3 выполнит приведение типов.  
- [x] Количество аргументов лямбды может быть меньше, чем количество столбцов в строке ответа.  
  - [x] В этом случае избыточные столбцы будут проигнорированы.  
- [x] Количество аргументов лямбды не должно быть больше, чем количество столбцов в строке ответа.  
  - [x] В релизе будет брошено исключение.  
  - [x] В дебаге сработает assert.  
- [x] База может прислать пустой ответ:  
  - [x] В этом случае лямбда запускаться не будет.  

<br />
<br />




# Получателем данных может быть объект пользовательского класса  
Используется для удобства.  
Пример:  

```
namespace test
{
    struct answer
    {
        size_t age;
    };

    void operator >>(db::request&& out, answer& dst)
    {
        return std::move(out) >> std::tie(dst.age);
    }

} // namespace test
```
Обратите внимание: `std::move(out)` объект `db::request` должен быть rvalue.  
Пример запроса:  

```
    const char* sql = "select age from users where login = ?";
    test::answer dst { 0 };
    connection << sql << 3 >> dst;
```

- [x] Поля пользовательской структуры соответствуют типам столбцов в строке ответа.  
- [x] Типы полей структуры могут не совпдать с типами столбцов:  
  - [x] В этом случае sqlite3 выполнит приведение типов.  
- [x] Количество полей структуры может быть меньше, чем количество столбцов в строке ответа.  
  - [x] В этом случае избыточные столбцы будут проигнорированы.  
- [x] Количество полей структуры не должно быть больше, чем количество столбцов в строке ответа.  
  - [x] В релизе будет брошено исключение.  
  - [x] В дебаге сработает assert.  
- [x] База может прислать пустой ответ:  
  - [x] В этом случае поля структуры останутся без изменений.  
- [x] Если количество строк в ответе будет больше одной:  
  - [x] В релизе первая строка будет обработана, а остальные проигнорированы.  
  - [x] В дебаге сработает assert.  

<br />
<br />




# Получателем данных может быть контейнер
Используется для удобства.  
Пример:  

```
namespace test
{
    struct users { size_t login, age; };

    void operator >>(db::request&& out, users& dst)
    {
        return std::move(out) >> std::tie(dst.login, dst.age);
    }

} // namespace test
```
Обратите внимание: `std::move(out)` объект `db::request` должен быть rvalue.  
Пример запроса:  

```
    const char* sql = "select * from users";
    std::list<users> dst_list;
    connection << sql >> dst_list;

    size_t count = 0;
    connection << "select count() from users" >> count;

    std::vector<users> dst_vector;
    dst_vector.reserve(count);
    connection << sql >> dst_vector;
```

ВАЖНО: специфика работы с базой такова, 
что нельзя сказать заранее, сколько будет записей в ответе базы.  
Поэтому, нет технической возможности автоматически запуситть `std::vector::reserve`.  
Но вы можете самостоятельно вызывать этот метод до исполнения запроса.  

- [ ] Элементами контейнера могут быть:
    - [ ] [Примитивы][7]:
      - [ ] const char*  
      - [ ] const str_t  
      - [ ] float или double.  
      - [ ] int любых размерностей.  
      - [ ] bool.  
    - [ ] [std::tuple][8]
    - [ ] [Пользовательские типы][9].
- [ ] Если база прислала пустой ответ, то контейнер останется без изменений.
- [ ] Если база прислала множество строк, то все они будут загружены в контейнер.

<br />
<br />


[7]: #operator-out                                                   "характерные для одиночных типов особенности"
[8]: #Получателем-данных-может-быть-stdtuple                         "характерные для std::tuple особенности и ограничения"  
[9]: #Получателем-данных-может-быть-объект-пользовательского-класса  "характерные для пользовательских типов особенности и ограничения"  








