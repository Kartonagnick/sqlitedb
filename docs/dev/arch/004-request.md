
request
-------
Служебный класс.  
Предназначен для установки аргументов запроса, и получения результатов.  

- [ ] [Требования][0]  
- [x] Члены класса:  
  - [ ] [Деструктор][1]  
  - [ ] [Конструкторы][2]  
  - [ ] Операторы присвоения запрещены.  
  - [ ] [operator<<(T&&)][3]  
  - [ ] [operator>>(T&&)][4]  

[0]: #Требования      "требования к реализации"  
[1]: #Деструктор      "описание деструктора"  
[2]: #Конструкторы    "описание конструкторов"  
[3]: #operator-in     "оператор ввода аргумента"  
[3]: #operator-out    "оператор вывода аргумента"  

<br />
<br />




Требования
----------
 - [x] Может быть создан только [connection](003-connection.md)  
 - [x] В нормальной ситуации остается временным объектом до конца жизни.  
 - [x] Не перемещаем.  
   - [x] Перемещающий конструктор существует, 
         но пользоваться им может только [connection](003-connection.md)  
 - [x] Не копируемый.  
 - [x] Операторы присвоения запрещены.  

<br />
<br />





Деструктор
----------

```cpp
~request();
```

- [ ] Защищён при помощи assert.  
- [ ] Гарантирует noexcept (no-throw guarantee).  
- [ ] Закрывает запрос, подтвердив все изменения .  

<br />
<br />





Конструкторы
------------

```cpp
private:
    request(request&&)     noexcept;
    request(stmtT* cursor) noexcept;
public:
    request(const request&)            = delete;
    request& operator=(const request&) = delete;
    request& operator=(request&&)      = delete;
```

- [x] Создать объект может только [connection](003-connection.md)  
- [x] Перемещать объект может только [connection](003-connection.md)  
- [x] Конструктор копии запрещен.
- [x] Операторы присвоения запрещены.

<br />
<br />


operator-in 
-----------
Служит для ввода аргументов запроса.  
```
    template<class T>
    request& operator << (T&& value) noexcept;
```

- [x] Возвращает ссылку на самого себя.  
- [x] Никогда не бросает исключений.  
- [x] Защищается assert  
- [ ] Поддерживаемые типы:  
  - [ ] const char*  
  - [ ] const str_t  
  - [ ] float или double.  
  - [ ] int любых размерностей.  
  - [ ] bool.  
- [x] Типы аргументов могут не совпадать с типами столбцов.  
  - [x] За исключением столбца PRIMARY KEY.  
    - [x] PRIMARY KEY обязан быть int (любой размерности).  

<br />
<br />






operator-out
------------
Служит для получения итоговых результатов запроса.  
```
    template<class T>
    void operator >> (T& dst);
```

- [x] Может бросить исключение. (например: std::bad_alloc)  
- [x] Защищается assert  
- [ ] Поддерживаемые типы:  
  - [ ] const char*  
  - [ ] const str_t  
  - [ ] float или double.  
  - [ ] int любых размерностей.  
  - [ ] bool.  
- [x] Типы аргументов могут не совпадать с типами столбцов.  
  - [x] За исключением столбца PRIMARY KEY.  
    - [x] PRIMARY KEY обязан быть int (любой размерности).  
- [ ] Количество строк ответа может быть больше, 
      чем ожидает получатель, но не меньше.  
- [ ] Количество столбцов в строке ответа может быть больше, 
      чем ожидает получатель, но не меньше.  

# Получателем данных может быть одиночная переменная
Используется в случаях, когда от базы в ответ 
ожидается одно единственное значение.  
И это единственное значение всегда должно быть.  
Например:  
  `Сonnection << "select count(*) from sample" >> count;`  

Здесь `count(*)` может быть либо ноль, либо больше.  
Но какое то значение всегда должно быть.  
Пустой ответ от базы расценивается как ошибка.  

- [x] Если база пришлет в ответ пустую строку:  
  - [x] В дебаге ->assert  
  - [x] В релизе -> исключение.  
- [x] Если база пришлет в ответ строку из нескольких столбцов:  
  - [x] Будет использованно значение только первого столбца.  
  - [x] Остальные столбцы будут проигонорированы.  
- [x] Если база пришлет несколько строк ответа:  
  - [x] В дебаге сработает assert  
  - [x] В релизе:  
    - [x] Будет использовано значение первого столбца первой строки.  
    - [x] Все остальное будет проигноированно.  

# Получателем данных может быть std::tuple
Используется в случаях, когда от базы в ответ 
ожидается одна строка из нескольких столбцов.  

Пример использования:
```
    std::tuple<str_t, int> dst
    Сonnection << "SELECT * FROM users WHERE login = 1" >> dst;
```

- [ ] Параметры std::tuple соответствуют типам столбцов в строке ответа.
- [ ] Параметры std::tuple не обязаны строго совпадать с типами столбцов в строке ответа.
  - [ ] Есди не совпадают -> sqlite3 выполнит приведение типов.
- [ ] Если количество параметров std::tuple больше, 
        чем количество столбцов в строке ответа, тогда:  
  - [ ] В релизе избыточные поля std::tuple будут проигнорированы.  
  - [ ] В дебаге сработает assert.  
- [ ] Если количество параметров std::tuple меньше, 
      чем количество столбцов в строке ответа, тогда:  
  - [ ] В релизе избыточные столбцы в строке ответа будут проигонированы.  
  - [ ] В дебаге сработает assert.  

# Получателем данных может быть лямбда  
Используется для перебора множества строк ответа базы.  
Пример: `auto getter = [](str_t&, int&) { return true; };`  

- [ ] Лямбда вызывается в цикле для обработки очередной строки.  
  - [ ] Если лямбда возвращает false -> это сигнал прекратить цикл.  
  - [ ] Если лямбда возвращает true -> это запрос следующей строки.  
- [ ] Аргументы лямбды соответствуют типам столбцов в строке ответа.  
- [ ] Типы аргументов могут не совпдать с типами столбцов:  
  - [ ] В этом случае sqlite3 выполнит приведение типов.  
- [ ] Количество аргументов лямбды может быть меньше, чем количество столбцов в строке ответа.  
  - [ ] В этом случае избыточные столбцы будут проигнорированы.  
- [ ] Количество аргументов лямбды не должно быть больше, чем количество столбцов в строке ответа.  
  - [ ] В релизе будет брошено исключение.  
  - [ ] В дебаге сработает assert.  
- [ ] База может прислать пустой ответ:  
  - [ ] В этом случае лямбда запускаться не будет.  


### debug

  - [ ] База может прислать пустой ответ.  
    - [ ] В этом случае std::tuple останется без изменений.  


  - [ ] Количество столбцов в строке ответа может быть больше, чем в std::tuple.  
    - [ ] В этом случае часть столбцов ответа справа будeт проигнорированно.  
  - [ ] Типы столбцов в ответе могут не совпадать с типами столбцов в std::tuple.  
    - [ ] В этом случае будет выполнено преобразование типов по правилам sqlite3.  
  - [ ] Количество строк ответа может быть:  
    - [ ] Ноль. В этом случае std::tuple останется без изменений.  
    - [ ] Одна. Это - идеальный случай.
    - [ ] Больше одной.  
      - [ ] В релазе все строки кроме первой будут проигноированны.  
      - [ ] В дебаге сработает assert.  

### Получателем данных может быть лямбда  
  - Например: `auto getter = [](str_t&, int&) { return true; };`  
  - Лямбда должна:  
    - Вернуть true, если нужно считать ещё одну строку ответа.  
    - Вернуть false, что бы прекратить перебор строк ответа.  
  - Количество строк в ответе может быть проивользным.  
    - Их может вообще не быть.  




Допустимые типы получателя:  
  - [x] str_t  
  - [x] float или double.  
  - [x] int любых размерностей.  
  - [x] bool.  
  - Либо лямбда с аргументами указанных выше типов:  
    - [x] Например такая:  
      - `auto getter = [](str_t&, int&) { return true; };`  
    - [x] Лямбда должна возвращать bool  
  - Либо std::tuple, параметризованный указанными выше типами:  
    - [x] Например такой: `std::tuple<str_t, int>`  
  - Либо std::tie, параметризованный указанными выше типами:  
    - [x] Например такой:  
      - `std::tie(text, age); //text b age - переменные типа str_t, и int соответственно`  
  - Либо std::list или std::vector, параметризованные указанными выше типами:  
    - [x] Например такие:  
      - `std::vector<int>`  
      - `std::list<str_t>`  
      - `std::list<std::tuple<str_t, int> >`  

